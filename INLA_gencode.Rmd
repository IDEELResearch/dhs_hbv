---
title: "INLA spatial modelling"
author: "Cedar Mitchell"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: textmate
    theme: cerulean
    toc: yes
    toc_depth: 2
    toc_float: yes
    df_print: paged
  word_document:
    toc: yes
    toc_depth: '2'
editor_options:
  chunk_output_type: console
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, eval = T, results = "asis")
```

```{r, echo=T}

####
#NOTE: This is formatted in markdown, but could take a while to knit, probably best to run in chunks...
####


#Load libraries:

library(tidyverse)
library(sf)
library(maptools)
library(spdep)
library(RColorBrewer)
library(lattice)
library(fields)
library(maps)
library(INLA)  #needs to be installed from here: install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(inlabru) #This is necessary for making pretty maps from INLA output


#Read in data:
gepr_full<-read_rds("DRC_Final_dataset_full_covariates.rds")

#Subset cluster locations:
locations<-gepr_full%>%
  select(longnum, latnum)

#bounding box for DRC
DRC <- sf::as_Spatial(osmdata::getbb("Democratic Republic of the Congo",
                                     featuretype = "country",
                                     format_out = 'sf_polygon'))
```

```{r}
# example from INLA article
data("Leuk")
view(Leuk)
loc <- cbind(Leuk$xcoord, Leuk$ycoord)
bnd1 <- inla.nonconvex.hull(loc, convex = 0.05)
bnd2 <- inla.nonconvex.hull(loc, convex = 0.25)
mesh <- inla.mesh.2d(loc, boundary = list(bnd1, bnd2), max.edge = c(0.05, 0.2), cutoff = 0.005)
# view the mesh and points
plot(mesh,asp=1)
points(loc[,1], loc[,2], col='red')

A <- inla.spde.make.A(mesh, loc)
spde <- inla.spde2.matern(mesh, alpha=2) # default choice
formula <- inla.surv(time, cens) ~ 0 +a0 + sex + age + wbc + tpi + f(spatial, model=spde)
stk <- inla.stack(data=list(time=Leuk$time, cens=Leuk$cens), 
                  A=list(A,1), 
                  effect=list(list(spatial=1:spde$n.spde), 
                  data.frame(a0=1, Leuk[,-c(1:4)])))

r <- inla(formula, family = "weibull", data=inla.stack.data(stk),
          control.predictor=list(A=inla.stack.A(stk)), verbose = T)

# hbv data
loc <- cbind(gepr_full$longnum, gepr_full$latnum)

bnd1 <- inla.nonconvex.hull(loc, convex = 0.05)
bnd2 <- inla.nonconvex.hull(loc, convex = 0.25)
mesh <- inla.mesh.2d(loc, boundary = list(bnd1, bnd2), max.edge = c(0.05, 0.2), cutoff = 0.005)
# view the mesh and points
plot(mesh,asp=1)
points(loc[,1], loc[,2], col='red')


A <- inla.spde.make.A(mesh, locations)
spde <- inla.spde2.matern(mesh, alpha=2) # default choice
formula <- hbvresult ~ 0 + hv104 + hv270 + hv025 + shtetaindasno + nohyphen  + f(spatial, model=spde)

# **********NEED TO GET THIS TO WORK**********
Stack <- INLA::inla.stack(
  data = list(y = kid_dhs_int_nomissgps[, "hbvresult"]), # specify the response variable
  tag = "est",

  A = list(1, 1, 1, A), # vector of multiplication factors for random and fixed effects
  # this is generally a series of 1â€™s (for the intercept, random effects, and fixed effects), followed by the spatial A matrix which you specified earlier.
  effects = list(
    Intercept = rep(1, N), # specify the manual intercept!
    X = X, # attach the model matrix
    cluster = kid_dhs_int_nomissgps$cluster_hh, # insert vectors of any random effects
    w = w)) # attach the weights for random effects


r <- inla(formula, family = "binomial", data=inla.stack.data(Stack),
          control.predictor=list(A=inla.stack.A(Stack)), verbose = T)


```




#1. first step is to create meshes:
  #Create 3 meshes, one with large edge values, one with medium, and the third with precise edge values
  #max edge, first value controls triangle size within boundary, second value is triangle size outside boundary

```{r, echo=T}
mesha<-inla.mesh.2d(locations,  max.edge = c(10, 20))   #edge values are in units of coordinates, these are decimal degrees
meshb<-inla.mesh.2d(locations,  max.edge = c(2, 10))
meshc<-inla.mesh.2d(locations,  max.edge = c(0.5, 2)) # smaller mesh, more precision but more computation


plot(mesha,asp=1)
points(locations$longnum,locations$latnum, col='red')

plot(meshb,asp=1)
points(locations$longnum,locations$latnum, col='red')

plot(meshc,asp=1)
points(locations$longnum,locations$latnum, col='red')


#Evaluate mesh formations (not necessary, but can be helpful):
outa <- inla.mesh.assessment(mesha,
                            spatial.range = 3,
                            alpha = 2)
outb <- inla.mesh.assessment(meshb,
                            spatial.range = 3,
                            alpha = 2)
outc <- inla.mesh.assessment(meshc,
                            spatial.range = 3,
                            alpha = 2)

ggplot() + gg(outa, aes(color = edge.len)) + coord_equal()
#Check standard dev values, should be close to 1
ggplot() + gg(outa, aes(color = sd.dev)) + coord_equal() +
  scale_color_gradient(limits = range(outa$sd.dev, na.rm = TRUE))

ggplot() + gg(outb, aes(color = edge.len)) + coord_equal()
#Check standard dev values, should be close to 1
ggplot() + gg(outb, aes(color = sd.dev)) + coord_equal() +
  scale_color_gradient(limits = range(outb$sd.dev, na.rm = TRUE))

ggplot() + gg(outc, aes(color = edge.len)) + coord_equal()
#Check standard dev values, should be close to 1
ggplot() + gg(outc, aes(color = sd.dev)) + coord_equal() +
  scale_color_gradient(limits = range(outc$sd.dev, na.rm = TRUE))

#Ideal mesh has standard deviation values near 1
#Again, this step isn't necessary, can just pick edge values for a mesh and go. Smaller edges are more computationally expensive.

# camille observations aug 2023 - all SDs range from ~0.9 to 1.3/1.4. doesn't seem mesh c has substantially better precision? (SD max 1.3 not 1.4 - depends on what is considered best)
```

#2. next step is to generate a matrix from triangulations
 Includes matrix, matern covariance structure, and weights

``` {r, echo=T}
#Make the PC matern covariance function. The starting range prior is typically 1/5 of the study domain:
size<-min(c(diff(range(meshc$loc[, 1])), diff(range(meshc$loc[, 2]))))
range0<-size/5

mat_spde = inla.spde2.pcmatern(mesh = meshc, prior.range = c(5.3, 0.5), prior.sigma = c(.5, .5)) # Making SPDE


##a) SPDE and weights for spatial random intercept
mat_a_id<-inla.spde.make.A(mesh=meshc, loc = cbind(locations$longnum,locations$latnum))
mat_s_w <- inla.spde.make.index('w', n.spde = mat_spde$n.spde) # making the weights

##b) SPDE and weights for spatiallly varying slope terms
mat_a_temp<-inla.spde.make.A(mesh=meshc, loc = cbind(locations$longnum,locations$latnum)) # cedar had , weights = gepr_full$temp_1mo_lag_s

mat_s_temp<-inla.spde.make.index('temp_w', n.spde = mat_spde$n.spde) #The 'n.spde' stays the same for all spatial effects that use the same covariance structure
  #You can create different covariance structures for different spatial effects (i.e. if you want to change the range prior for a specific covariate)

  #Make a matrix and index for each spatially varying coefficient

```

#3. Final step is to create covariate matrix and stack all matrices together

```{r, echo=T}

#Covariate matrix

df_covar = data.frame(intercept=1,           #Need to specify manual intercept, should be set to 1
                               temp=gepr_full$temp_1mo_lag_s,   #include only the variables that you need in the model
                               precip=gepr_full$precip_no_lag,
                               veg=gepr_full$evi_no_lag,
                               elev=gepr_full$elevation_m,
                      pop_dens=scale(gepr_full$pop_density_km),
                      water=scale(gepr_full$water_dist_km),
                      logging=gepr_full$logging_10k,
                      mining=gepr_full$mining_10k)

X0 <- model.matrix(as.formula("~ -1 + shtetaindasno + hv104 + hv270 + hv025"), data = dat) # + nohyphen
formula <- hbvresult ~ 0 + hv104 + hv270 + hv025 + shtetaindasno + nohyphen  + f(spatial, model=spde)


#Construct stacks using 8 degree range for all spatial random effects
stack_all <- inla.stack(
  data = list(y = dat$hbvresult),tag='est', # specify the response variable
  
  A = list(1, 1, mat_a_id, mat_a_temp), # Vector of Multiplication factors for random and fixed effects (order listed needs to match the order of the effects below, use '1' for any non-spatial effects)              
  
  effects = list(
    
    X = X0, # attach the covariate matrix
    
    ID = dat$hv001 # insert vectors of any non-spatial random effects
    
   )) # w = mat_s_w,    #now the weights (inla.spde.make.index) for all the SPDE random effects variables
   #  temp_w = mat_s_temp)


```

#4. Running INLA models

```{r, echo=T}
##First, a function to bind model results together:
#_____________________________________________________________________________________________
inla_df<-function(mod,vars, caption){
  ret<-cbind.data.frame(rbind.data.frame(as.data.frame(mod$summary.fixed[,1:6], row.names=vars), as.data.frame(mod$summary.hyperpar[,1:6])), 
    as.data.frame(mod$dic$dic))%>%
    
    mutate(varname=rownames(.),
         Estimate=mean, model=caption, lci=`0.025quant`, uci=`0.975quant`, DIC=`mod$dic$dic`)%>%
    dplyr::select(varname, Estimate, model, sd, lci, uci, DIC)
  return(ret)
}
#______________________________________________________________________________________________


##a. start with non-spatial INLA models with random intercept for cluster only

IM0<-inla(y ~ 0 + intercept +temp+precip+veg+elev+pop_dens+water+
            f(ID, model="iid"), #non-spatial random intercept model
            family = "binomial",
            data = inla.stack.data(stack_all),
            control.compute = list(dic = TRUE),
            control.predictor = list(A = inla.stack.A(stack_all))
)

IM0_df<-inla_df(mod = IM0, vars=c("intercept", "temp","precip","veg", "elev", "pop_dens", "water"),caption = "none")

##b. Fixed effects + random intercept + spatial intercept
IM1<-inla(y ~ 0 + intercept +temp+precip+veg+elev+pop_dens+water+
            f(ID, model="iid")+  #Random intercept model
            f(w, model=mat_spde), # spatially varying intercept model
            family = "binomial", verbose = T,
            data = inla.stack.data(stack_all),
            control.compute = list(dic = TRUE),
            control.predictor = list(A = inla.stack.A(stack_all))
)

IM1_df<-inla_df(mod=IM1, vars=c("intercept", "temp","precip","veg", "elev", "pop_dens", "water"),caption = "Intercept")

##c. Fixed effects + random intercept + spatial intercept + spatial slope
  ##Spatially varying slopes can take a while to run, especially in a large dataset (this model took my laptop 30mins to run...)

IM2<-inla(y ~ 0 + intercept+precip+veg+elev +pop_dens+water+
            f(ID, model="iid")+  #Random intercept model
            f(w, model=mat_spde)+  #Spatially varying intercept model
            f(temp_w, model=mat_spde),  #Spatially varying slope model (if including, need to remove covariate from fixed effects)
            family = "binomial",
            data = inla.stack.data(stack_all),
            control.compute = list(dic = TRUE),
            control.predictor = list(A = inla.stack.A(stack_all))
)

IM2_df<-inla_df(mod=IM2,vars =c("intercept","precip","veg", "elev",  "pop_dens", "water"), caption="Int + temp")

```

#Plotting results: 
There are many different ways to do this, I'll include an ugly version and a prettier version, but the nicer one can throw a lot of errors about crs compatibility...

```{r, echo=T}
##1) Function from Franco-Villoria et al.
local.plot.field = function(field, meshc, xlim=c(12, 32), ylim=c(-14, 6), res=500, ...){
  stopifnot(length(field) == meshc$n)
  # - error when using the wrong mesh
  proj = inla.mesh.projector(meshc, xlim = xlim, 
                             ylim = ylim, dims=c(res, res))
  # - Can project from the mesh onto a 300x300 plotting grid 
  field.proj = inla.mesh.project(proj, field)
  # - Do the projection
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, ...)  
}


m = IM1 #Specify results to plot

#spatial random intercept
local.plot.field(m$summary.ran$w$mean, meshc ,axes=F)
plot(DRC, add=T)
box()

#Variance of spatial random intercept
local.plot.field(m$summary.ran$w$sd, meshc ,axes=F)
plot(DRC, add=T)
box()

#__________________________

m=IM2

#spatial random slope
local.plot.field(m$summary.ran$temp_w$mean, meshc ,axes=F)
plot(DRC, add=T)
box()

#Variance of spatial random slope
local.plot.field(m$summary.ran$temp_w$sd, meshc ,axes=F)
plot(DRC, add=T)
box()

#________________________

##2) Function from inlabru
  #This makes a really nice figure, but requires adding a crs to the original spatial mesh which is a nightmare


inlaplot<-function(m, colo,nam){
  ip<-ggplot()+
  gg(meshc, color=m, mask=DRC)+
  gg(DRC)+
  coord_equal()+
  scale_fill_gradientn(colours = rev(RColorBrewer::brewer.pal(11, colo)), 
                       name=nam)+
    xlab("Easting")+
    ylab("Northing")+
  theme_bw()
  return(ip)
}

inlaplot(m=IM1$summary.random$w$mean, colo="RdYlBu", nam="Spatial intercept\nmean")
inlaplot( m=IM1$summary.random$w$sd,colo="Blues", nam="Spatial intercept\nSD")

ggsave(filename="", device="tiff",
          height=5, width=5, units="in", dpi=900, bg="transparent")

```

### Extra INLA code for a non-spatial model (can specify hyper priors etc.)

```{r, echo=T}
#Function for summary of model results:
#_______________________________________________________________________________________
base_df<-function(mod,rnames, caption){
  ret<-cbind.data.frame(rbind.data.frame(as.data.frame(mod$summary.fixed[,1:6], row.names=rnames), as.data.frame(mod$summary.hyperpar[,1:6])), 
    as.data.frame(mod$dic$dic))%>%
    
    mutate(varname=rownames(.),
         Estimate=mean, model=caption, lci=`0.025quant`, uci=`0.975quant`, DIC=`mod$dic$dic`)%>%
    dplyr::select(varname, Estimate, model, sd, lci, uci, DIC)
  return(ret)
}
#______________________________________________________________________________________

BM1.0<-inla(pfldh ~ 1 + temp_1mo_lag_s1+pop_density_km+water_dist_km+
              f(hv001, model="iid",hyper=list(theta=list(param=c(1,0.01)))), # Base model (random effects for intercept only)
            family = "binomial",
            data = gepr_full,
            control.compute = list(dic = TRUE),
            control.predictor = list(compute = TRUE), control.fixed=list(mean=0,prec=0.01)
)

BM1.0df<-base_df(mod=BM1.0, rnames=c("Intercept", "temp", "pop_density", "water"), caption=" temp  only")

```
# Krigging with INLA

```{r, echo=T}
library(raster)
library(lattice)
library(fields)
library(splancs)


#First, set up mesh for full dataset
#***Note that I transformed everything to a UTM projection, it's important that everything has the same CRS for this, otherwise the prediction grid doesn't line up with the study locations

  #Projection transformation:
DRC <- sf::as_Spatial(osmdata::getbb("Democratic Republic of the Congo",
                                     featuretype = "country",
                                     format_out = 'sf_polygon'))
#Set up CRS:
drc_crs_km<-CRS("+proj=utm +zone=33S +datum=WGS84 +units=km +no_defs +ellps=WGS84") #set DRC coordinates system to meters

drc_coords_css<-CRS("+proj=longlat +datum=WGS84") #need coordinate system for lat long

locations<-gepr_full%>%
  dplyr::select(longnum, latnum)

locations_st<-st_as_sf(locations,coords = c("longnum", "latnum"), crs=drc_coords_css)%>%
  st_transform(., drc_crs_km)  #define lat long coordinate system and transform to meters

locations_km<-as.data.frame(locations_st)%>%unnest_wider(geometry, names_sep = c("x", "y"))%>%
  rename(x=geometryx1,
         y=geometryy2)

drc_km<-sf::as_Spatial(st_as_sf(DRC)%>%
    st_transform(drc_crs_km))

drc_border<-raster::geom(drc_km)

#1. Define mesh


meshc<-inla.mesh.2d(locations_km,  max.edge = c(50, 200))

plot(meshc,asp=1)
points(locations_km$x,locations_km$y, col='red')
plot(drc_km, add=T)

##2. Spatial effects A matrix, matern covariance, and index files
loc = cbind(locations_km$x,locations_km$y)

mat_a_id<-inla.spde.make.A(mesh=meshc, loc = loc) #A matrix for global spatial effects

mat_spde = inla.spde2.pcmatern(mesh = meshc, prior.range = c(600, 0.5), prior.sigma = c(.5, .5)) # Making SPDE

mat_w_id <- inla.spde.make.index('w', n.spde = mat_spde$n.spde) # making the weights for spatial locations

##3. Dataframe of intercept values:
df_covar = data.frame(intercept = 1,
                      temp=gepr_full$temp_1mo_lag_s,
                      precip=gepr_full$precip_no_lag,
                      veg=gepr_full$evi_no_lag,
                      elev=gepr_full$elevation_m)

##4. Stack of random effects and covars
stack_p_all <- inla.stack(
  data = list(y = gepr_full$pfldh),tag='est', # specify the response variable
  
  A = list(1, 1, mat_a_id), # Vector of Multiplication factors for random and fixed effects              
  
  effects = list(
    
    X = df_covar, # attach the model matrix
    
    ID = gepr_full$hv001, # insert vectors of any random effects
    
    w = mat_w_id))


##5. Set up prediction grid

nxy <- c(450, 450) #resolution of the prediction grid

projgrid <- inla.mesh.projector(meshc, xlim = range(drc_border[, 5]), ylim = range(drc_border[, 6]), dims = nxy)

#locations outside of prediction grid (IMPORTANT!)

xy.in <- inout(projgrid$lattice$loc, cbind(drc_border[, 5]+10, drc_border[, 6]+10))

#Plot prediction grid and make sure everything looks good
coord.prd <- projgrid$lattice$loc[xy.in, ]
plot(coord.prd, type = "p", cex=0.1)
lines(drc_border)
points(locations_km$x, locations_km$y, pch = 19, cex = 0.5, col = "red")

##6. link projection grid to data
#a) Define a matrix
A.prd <- projgrid$proj$A[xy.in, ]

#b) Generate list of effects (mostly location ids and coordinates)
ef.prd = list(c(mat_w_id, list(intercept = 1)), list(long = inla.group(coord.prd[, 
    1]), lat = inla.group(coord.prd[, 2])))

#c) Create a prediction stack, note that the response is set to NA since that will be predicted
stk.prd <- inla.stack(data = list(y = NA), 
                      A = list(A.prd, 1), tag = "prd", 
    effects = ef.prd)
#d) Stack together the data stack (stack_p_all) and the prediction stack (stk.prd)
stk.all <- inla.stack(stack_p_all, stk.prd)

##7. Estimate predictions (This can take a while depending on prediction grid resolution)
r2.s <- inla(y ~ 0 + intercept + f(ID, model = "iid") + f(w, model=mat_spde), family = "binomial", data = inla.stack.data(stk.all), control.predictor = list(A = inla.stack.A(stk.all), 
    compute = TRUE, link=1), quantiles = NULL, control.results = list(return.marginals.random = F, 
    return.marginals.predictor = F), verbose = TRUE)


##8. Extract indexes to prediction nodes and extract mean and std

id.prd <- inla.stack.index(stk.all, "prd")$data #The "prd" here calls the prediction stack
sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2])
m.prd[xy.in] <- r2.s$summary.fitted.values$mean[id.prd]
sd.prd[xy.in] <- r2.s$summary.fitted.values$sd[id.prd]

##9. Plot results

#a) results for posterior predicted means:

clrs.rdylbu <- colorRampPalette(rev(brewer.pal(11, "RdYlBu" )))

levelplot(m.prd, col.regions = clrs.rdylbu(1001), xlab = "", ylab = "", 
    scales = list(draw = FALSE))+
  layer(sp.polygons(drc_km, lwd=2))

#b) results for posterior predicted stdevs
clrs.bu <- colorRampPalette(rev(brewer.pal(9, "Blues" )))

levelplot(sd.prd, col.regions = clrs.bu(1001), xlab = "", ylab = "", 
    scales = list(draw = FALSE))+
  layer(sp.polygons(drc_km, lwd=2))

### Simple combination of mean and Stdev plots:

gridExtra::grid.arrange(levelplot(m.prd, col.regions = tim.colors(1001), xlab = "", ylab = "", 
    main = "mean", scales = list(draw = FALSE)), levelplot(sd.prd, col.regions = topo.colors(99), 
    xlab = "", ylab = "", scales = list(draw = FALSE), main = "standard deviation"))


### Nicer raster file of posterior means plot
xmean2 <- t(m.prd)
xmean3 <- xmean2[rev(1:length(xmean2[,1])),] #need to transform and rotate matrix input for correct raster orientation
xmean_ras <- raster(xmean3,
                    xmn = range(projgrid$x)[1], xmx = range(projgrid$x)[2],
                    ymn = range(projgrid$y)[1], ymx = range(projgrid$y)[2],
                    crs = CRS("+proj=utm +zone=33S +datum=WGS84 +units=km +no_defs +ellps=WGS84"))


raster::writeRaster(xmean_ras, filename = "C:/Users/Cedar/Desktop/Dissertation/Analysis/Dissertation/Model Development/DRC_krigged_Pf_prev.tif", overwrite=T, options=c('TFW=YES'))

```
